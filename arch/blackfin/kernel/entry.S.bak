/*
 *  linux/arch/bfinnommu/mach-bf533/entry.S
 *
 *  Copyright (C) 1991, 1992  Linus Torvalds
 *  Copyright (C) 2001 SED Systems, a Division of Calian Ltd.
 *  Copyright (C) 2004 LG Soft India.
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file README.legal in the main directory of this archive
 * for more details.
 *
 * Linux/m68k support by Hamish Macdonald
 * M68360 Port by SED Systems, and Lineo.
 * Linux/bfin support by LG Soft India.
 */

#include <linux/config.h>
#include <linux/sys.h>
#include <linux/linkage.h>
#include <asm/thread_info.h>
#include <asm/errno.h>
#include <asm/setup.h>
#include <asm/segment.h>
#include <asm/asm-offsets.h>
#include <asm/entry.h>

.text

.globl buserr
.globl trap
.globl ret_from_exception
.globl ret_from_signal
.globl sys_fork
.globl sys_clone
.globl sys_vfork


ENTRY(reschedule)
	r7 = sp;   
	r4.l = 0xe000;
	r4.h = 0xffff;
	
	r7 = r7 & r4;  /*thread_info*/
	p2 = r7; 
	p2 = [p2];
	[p2 + (TASK_THREAD + THREAD_ESP0)] = sp;

	[--sp] = rets;
	call schedule; 
	rets = [sp++];
	rts;
ENTRY(reschedule2)
	/* save top of frame*/
	r7 = sp;    
	r4.l = 0xe000;
	r4.h = 0xffff;
	r7 = r7 & r4;  /*thread_info*/
	p2 = r7; 
	p2 = [p2];
	[p2+(TASK_THREAD+THREAD_ESP0)] = sp;

	p3.l = ret_from_exception;
	p3.h = ret_from_exception;
	rets = p3;
	jump.l schedule; /* unknow how far away */ 
	/* Note: asmlinkage void schedule(void) */

	/* After a fork we jump here directly from resume,*/
	/* so that %r1 contains the previous task*/
	/* Theoretically only needed on SMP, but let's watch*/
	/* what happens in schedule_tail() in future...*/


ENTRY(ret_from_fork)
	/* Don't bother with trace yet - akale */
	r0 = r1;
	call schedule_tail; 
	/* Note: void schedule_tail(struct task_struct *prev)	*/
	
	r0 = [sp + PT_IPEND];
	cc = bittst(r0, 15);
	if cc jump in_kernel;
	RESTORE_ALL_SYS		/*BFin*/
	rti; 
in_kernel:
	/* do a 'fake' RTI by jumping to [RETI] */
        /* to avoid clearing supervisor mode in child */
	RESTORE_ALL_SYS		/*BFin*/
	p0 = reti;
	jump (p0);
	/* NO! jump.s SYMBOL_NAME(ret_from_exception); */


/*BFin - New Entry*/
/*
ENTRY(sys_execve)	

	LINK 0x0;
	[--SP] = P0;
	P0 = SP;
	P0 += 16;
	[--SP] = P0;
	CALL bfin_execve;
	SP += 4;
	P0 = [SP++];
	UNLINK;
	RTS;
*/

ENTRY(sys_fork)	
	LINK 0x0;
	R0 = -EINVAL;
	UNLINK 0x0;
	RTS;

ENTRY(sys_vfork)		/*BFin*/
	LINK 0x0;
	R0 = 0;
	[--SP] = R0;
	R2 = FP;
	R2 += 16;
	R1 = USP;
	R0 = 0x4111;		/*CLONE_VFORK | CLONE_VM | SIGCHLD */
	CALL do_fork; 
	SP += 4;
	UNLINK ;
	RTS;

ENTRY(sys_dump)
	LINK 0x0;
	R0 = FP;
	R0 +=16;
	CALL	dump;
	UNLINK;
	RTS;

ENTRY(sys_clone)		/*BFin*/
	LINK 0x0;
	CC = R1 == 0;  
	R2 = USP;
	IF CC R1 = R2;
	R2 = 0;
	[--SP] = R2;
	R2 = FP;
	R2 +=16;
	CALL	do_fork;
	SP += 4;
	UNLINK; 
	RTS;


ENTRY(sys_sigsuspend)		/*BFin*/
	LINK 0X0;
	P0 = FP;
	P0 += 16;
	[--SP] = P0;
	CALL	do_sigsuspend; 
	SP += 4;
	UNLINK;
	RTS;

ENTRY(sys_rt_sigsuspend)	/*BFin*/
	LINK 0X0;
	R2 = FP;
	R2 += 16;
	CALL	do_rt_sigsuspend; 
	UNLINK;
	RTS;

ENTRY(sys_sigreturn)		/*BFin*/
	LINK 0x0;
	R0 = FP;
	R0 += 16;
	CALL	do_sigreturn;
	UNLINK; 
	rts;

ENTRY(sys_rt_sigreturn)		/*BFin*/
	LINK 0x0;
	R0 = FP;
	R0 +=16;
	CALL	do_rt_sigreturn; 
	UNLINK;
	RTS;

